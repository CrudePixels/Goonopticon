{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,8BAAuB;AACpD;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B;AAC7B,aAAa;AACb;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA,+BAA+B,uBAAuB;AACtD,6BAA6B,uBAAuB;AACpD,sCAAsC,uCAAuC;AAC7E,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AAChB;AACA;AACA;AACA;AACA;AACP;AACA;AACO,QAAQ,QAAQ;AAChB,QAAQ,YAAY;AACpB,QAAQ,iFAAiF;;;;;;;UCjKhG;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;ACNiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D,MAAM;AACN;AACA,sDAAsD,MAAM;AAC5D,MAAM;AACN;AACA,sDAAsD,MAAM;AAC5D,MAAM;AACN;AACA,qDAAqD,MAAM;AAC3D;AACA;;AAEA;AACA,QAAQ,oBAAO,IAAI,4BAAe,IAAI,4BAAe;AACrD;AACA;AACA;AACA,iBAAiB,4BAAe;AAChC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAAe,eAAe,uBAAuB;AACjE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;ACvGkC;AACe;;AAEjD;AACA,4BAAe;AACf;AACA,IAAI,MAAM;AACV;AACA;AACA;AACA;AACA,QAAQ,4BAAe;AACvB,gBAAgB,4BAAe;AAC/B,gBAAgB,MAAM,6BAA6B,4BAAe;AAClE,+CAA+C,iBAAiB;AAChE;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,YAAY,4BAAe,aAAa,4BAA4B;AACpE,oBAAoB,4BAAe;AACnC,oBAAoB,MAAM,6BAA6B,4BAAe;AACtE,mDAAmD,iBAAiB;AACpE;AACA;AACA,gBAAgB,MAAM;AACtB,+CAA+C,cAAc;AAC7D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM;AACd;AACA,2CAA2C,eAAe;AAC1D,SAAS;AACT,YAAY,MAAM;AAClB,2CAA2C,sCAAsC;AACjF,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI,MAAM;AACV;AACA,CAAC;;AAED;AACA,4BAAe;AACf;AACA,IAAI,MAAM;AACV,IAAI,MAAM;AACV;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA,+BAA+B,4BAAe;AAC9C,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,4BAAe;AAC/B,wBAAwB,4BAAe;AACvC,+BAA+B,4BAAe;AAC9C,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,gDAAgD;AAChD;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAAe,aAAa,sBAAsB;AAC9D,oBAAoB,4BAAe;AACnC,2BAA2B,4BAAe;AAC1C,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA,gBAAgB,4BAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB,4BAAe;AACvC,+BAA+B,4BAAe;AAC9C,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,YAAY,kCAAqB;AACjC;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,aAAa;AACb,UAAU;AACV,YAAY,MAAM;AAClB;AACA,gBAAgB,4BAAe,aAAa,wBAAwB;AACpE,wBAAwB,4BAAe;AACvC,+BAA+B,4BAAe;AAC9C,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,MAAM;AACN,QAAQ,MAAM;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAA8C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kB","sources":["webpack://podawfultimestamps/./JS/browser-polyfill-fix.js","webpack://podawfultimestamps/webpack/bootstrap","webpack://podawfultimestamps/webpack/runtime/define property getters","webpack://podawfultimestamps/webpack/runtime/hasOwnProperty shorthand","webpack://podawfultimestamps/webpack/runtime/make namespace object","webpack://podawfultimestamps/./JS/log.js","webpack://podawfultimestamps/./JS/background.js"],"sourcesContent":["// Browser Polyfill Fix\r\n// Ensures browser API is available in all contexts\r\n\r\n// Try to import webextension-polyfill\r\nlet browser;\r\ntry {\r\n    const polyfill = require('webextension-polyfill');\r\n    browser = polyfill.default || polyfill;\r\n} catch (err) {\r\n    // Fallback: try to use global browser object\r\n    if (typeof globalThis !== 'undefined' && globalThis.browser) {\r\n        browser = globalThis.browser;\r\n    } else if (typeof window !== 'undefined' && window.browser) {\r\n        browser = window.browser;\r\n    } else if (typeof chrome !== 'undefined') {\r\n        // Chrome fallback\r\n        browser = {\r\n            storage: {\r\n                local: {\r\n                    get: (keys, callback) => {\r\n                        if (typeof keys === 'function') {\r\n                            callback = keys;\r\n                            keys = null;\r\n                        }\r\n                        if (callback) {\r\n                            chrome.storage.local.get(keys, callback);\r\n                        } else {\r\n                            return new Promise((resolve, reject) => {\r\n                                chrome.storage.local.get(keys, (result) => {\r\n                                    if (chrome.runtime.lastError) {\r\n                                        reject(chrome.runtime.lastError);\r\n                                    } else {\r\n                                        resolve(result);\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                    },\r\n                    set: (items, callback) => {\r\n                        if (callback) {\r\n                            chrome.storage.local.set(items, callback);\r\n                        } else {\r\n                            return new Promise((resolve, reject) => {\r\n                                chrome.storage.local.set(items, () => {\r\n                                    if (chrome.runtime.lastError) {\r\n                                        reject(chrome.runtime.lastError);\r\n                                    } else {\r\n                                        resolve();\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                    },\r\n                    remove: (keys, callback) => {\r\n                        if (callback) {\r\n                            chrome.storage.local.remove(keys, callback);\r\n                        } else {\r\n                            return new Promise((resolve, reject) => {\r\n                                chrome.storage.local.remove(keys, () => {\r\n                                    if (chrome.runtime.lastError) {\r\n                                        reject(chrome.runtime.lastError);\r\n                                    } else {\r\n                                        resolve();\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                    },\r\n                    clear: (callback) => {\r\n                        if (callback) {\r\n                            chrome.storage.local.clear(callback);\r\n                        } else {\r\n                            return new Promise((resolve, reject) => {\r\n                                chrome.storage.local.clear(() => {\r\n                                    if (chrome.runtime.lastError) {\r\n                                        reject(chrome.runtime.lastError);\r\n                                    } else {\r\n                                        resolve();\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                    }\r\n                },\r\n                onChanged: chrome.storage.onChanged\r\n            },\r\n            runtime: {\r\n                getURL: (path) => chrome.runtime.getURL(path),\r\n                lastError: chrome.runtime.lastError,\r\n                onMessage: chrome.runtime.onMessage,\r\n                sendMessage: chrome.runtime.sendMessage,\r\n                onInstalled: chrome.runtime.onInstalled,\r\n                onStartup: chrome.runtime.onStartup,\r\n                getManifest: () => chrome.runtime.getManifest()\r\n            },\r\n            tabs: chrome.tabs,\r\n            notifications: chrome.notifications,\r\n            scripting: chrome.scripting\r\n        };\r\n    } else {\r\n        // Mock browser object for testing\r\n        browser = {\r\n            storage: {\r\n                local: {\r\n                    get: (keys, callback) => {\r\n                        setTimeout(() => callback({}), 0);\r\n                    },\r\n                    set: (items, callback) => {\r\n                        setTimeout(() => callback(), 0);\r\n                    },\r\n                    remove: (keys, callback) => {\r\n                        setTimeout(() => callback(), 0);\r\n                    },\r\n                    clear: (callback) => {\r\n                        setTimeout(() => callback(), 0);\r\n                    }\r\n                },\r\n                onChanged: { addListener: () => {} }\r\n            },\r\n            runtime: {\r\n                getURL: (path) => path,\r\n                lastError: null,\r\n                onMessage: { addListener: () => {} },\r\n                sendMessage: () => Promise.resolve(),\r\n                onInstalled: { addListener: () => {} },\r\n                onStartup: { addListener: () => {} },\r\n                getManifest: () => ({ version: \"2.0.7\", name: \"Goonopticon\" })\r\n            },\r\n            tabs: {\r\n                query: () => Promise.resolve([]),\r\n                sendMessage: () => Promise.resolve()\r\n            },\r\n            notifications: {\r\n                create: () => Promise.resolve()\r\n            },\r\n            scripting: {\r\n                executeScript: () => Promise.resolve()\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\n// Make browser available globally\r\nif (typeof globalThis !== 'undefined') {\r\n    globalThis.browser = browser;\r\n}\r\nif (typeof window !== 'undefined') {\r\n    window.browser = browser;\r\n}\r\n\r\n// Export both default and named exports\r\nexport default browser;\r\nexport const storage = browser.storage;\r\nexport const runtime = browser.runtime;\r\nexport const tabs = browser.tabs;\r\nexport const notifications = browser.notifications;\r\nexport const scripting = browser.scripting;\r\n\r\n// Export individual storage and runtime properties for compatibility\r\nexport const { local } = browser.storage;\r\nexport const { onChanged } = browser.storage;\r\nexport const { onInstalled, onStartup, getURL, lastError, onMessage, sendMessage, getManifest } = browser.runtime;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as browser from 'webextension-polyfill';\n/**\n * Logs a message to the console and to persistent storage (dev log), with color coding.\n * All logs are sent to the background script for unified storage in browser.storage.local.\n * \n * Log Types:\n * - error: red, for all errors\n * - warning: orange, for non-critical issues\n * - system: brown, for system functions like updating, installing, etc.\n * - interaction: white, for all interactable things (buttons, confirmations, moving, renaming, deleting, etc.)\n * - event: grey, for dispatched events, listener callbacks, etc.\n * - render: green, for anything that shows on screen\n * - data: blue, for information that is populated, loaded, or written\n * - performance: yellow, for tracking render speed or execution time\n * - miscellaneous: purple, for anything else\n * \n * @param {string|object} Message - The message or object to log.\n * @param {string} [Type=\"miscellaneous\"] - The log type.\n * @param {function} [Cb] - Optional callback for completion or error.\n */\nexport function LogDev(Message, Type = \"miscellaneous\", Cb)\n{\n    const colorMap = {\n        error: \"red\",\n        warning: \"orange\",\n        system: \"brown\",\n        interaction: \"white\",\n        event: \"grey\",\n        render: \"green\",\n        data: \"blue\",\n        performance: \"yellow\",\n        miscellaneous: \"purple\"\n    };\n    const color = colorMap[Type] || colorMap.miscellaneous;\n    const msgStr = typeof Message === \"string\" ? Message : JSON.stringify(Message);\n\n    // Remove or comment out all direct console.log, console.error, and console.warn statements in favor of LogDev.\n    // Console log for dev\n    /*\n    if (Type === \"error\")\n    {\n        console.error(\"%c[DevLog] \" + msgStr, `color:${color}`);\n    } else if (Type === \"warning\")\n    {\n        console.warn(\"%c[DevLog] \" + msgStr, `color:${color}`);\n    } else if (Type === \"system\")\n    {\n        console.info(\"%c[DevLog] \" + msgStr, `color:${color}`);\n    } else\n    {\n        console.log(\"%c[DevLog] \" + msgStr, `color:${color}`);\n    }\n    */\n\n    // Always send to background for unified logging\n    if (browser && browser.runtime && browser.runtime.sendMessage) {\n        // Check if extension context is still valid\n        try {\n            // Test if runtime is still available\n            if (!browser.runtime.id) {\n                // Extension context is invalid, skip logging\n                if (typeof Cb === 'function') Cb(null);\n                return;\n            }\n        } catch (e) {\n            // Extension context is invalid, skip logging\n            if (typeof Cb === 'function') Cb(null);\n            return;\n        }\n\n        const entry = {\n            time: new Date().toISOString(),\n            action: msgStr,\n            type: typeof Type === \"string\" ? Type : \"miscellaneous\",\n            color: color\n        };\n        \n        // Wrap in try-catch to handle immediate context invalidation\n        try {\n            browser.runtime.sendMessage({ type: \"devlog\", entry })\n                .then((response) => {\n                    if (typeof Cb === 'function') Cb(null);\n                })\n                .catch((err) => {\n                    // Suppress extension context errors\n                    if (err && (/(Extension context invalidated|Receiving end does not exist)/i).test(err.message)) {\n                        // Silently ignore these errors\n                        if (typeof Cb === 'function') Cb(null);\n                        return;\n                    }\n                    // Log other errors\n                    console.error(\"SendMessage failed:\", err?.message);\n                    if (typeof Cb === 'function') Cb(err);\n                });\n        } catch (e) {\n            // Handle immediate context invalidation\n            if (typeof Cb === 'function') Cb(null);\n        }\n        return;\n    }\n}\nif (typeof window !== \"undefined\") {\n  window.LogDev = LogDev;\n}","import { LogDev } from './log.js';\nimport * as browser from 'webextension-polyfill';\n\n// Listen for devlog messages from any context and store them in browser.storage.local\nbrowser.runtime.onMessage.addListener((msg, sender, sendResponse) =>\n{\n    LogDev(\"Received message in background: \" + JSON.stringify(msg), \"event\");\n    \n    // Handle devlog messages\n    if (msg && msg.type === \"devlog\" && msg.entry)\n    {\n        browser.storage.local.get([\"PodAwful::DevLog\"], (result) => {\n            if (browser.runtime.lastError) {\n                LogDev(\"Error fetching DevLog: \" + browser.runtime.lastError, \"error\");\n                sendResponse && sendResponse({ status: \"error\" });\n                return;\n            }\n            \n            LogDev(\"Fetched current DevLog from storage\", \"data\");\n            let DevLog = Array.isArray(result[\"PodAwful::DevLog\"]) ? result[\"PodAwful::DevLog\"] : [];\n            DevLog.push(msg.entry);\n            if (DevLog.length > 100)\n            {\n                LogDev(\"DevLog exceeded 100 entries, removing oldest\", \"performance\");\n                DevLog.shift();\n            }\n            browser.storage.local.set({ \"PodAwful::DevLog\": DevLog }, () => {\n                if (browser.runtime.lastError) {\n                    LogDev(\"Error updating DevLog: \" + browser.runtime.lastError, \"error\");\n                    sendResponse && sendResponse({ status: \"error\" });\n                    return;\n                }\n                LogDev(\"Updated DevLog in storage\", \"data\");\n                sendResponse && sendResponse({ status: \"ok\" });\n            });\n        });\n        // Required for async sendResponse\n        return true;\n    }\n    \n    // Handle manual update check requests\n    if (msg && msg.action === \"checkForUpdates\") {\n        LogDev(\"Manual update check requested\", \"system\");\n        checkForUpdates(true).then(() => {\n            sendResponse && sendResponse({ success: true });\n        }).catch((error) => {\n            LogDev(\"Error during manual update check: \" + error.message, \"error\");\n            sendResponse && sendResponse({ success: false, error: error.message });\n        });\n        // Required for async sendResponse\n        return true;\n    }\n    \n    LogDev(\"Unhandled message received in background\", \"miscellaneous\");\n    // ...other message handling...\n});\n\n// System event logging for install/update\nbrowser.runtime.onInstalled.addListener((details) =>\n{\n    LogDev(\"onInstalled event triggered\", \"system\");\n    LogDev(\"Extension installed/updated: \" + details.reason, \"system\");\n    \n    // Check for updates on install/update\n    if (details.reason === 'install' || details.reason === 'update') {\n        checkForUpdates();\n    }\n});\n\n// Update checking functionality\nasync function checkForUpdates(forceCheck = false) {\n    try {\n        LogDev(\"Checking for extension updates...\", \"system\");\n        \n        // Get current version\n        const currentVersion = browser.runtime.getManifest().version;\n        LogDev(\"Current version: \" + currentVersion, \"system\");\n        \n        // Check if we should check for updates (avoid checking too frequently, unless forced)\n        if (!forceCheck) {\n            const lastCheck = await new Promise((resolve, reject) => {\n                browser.storage.local.get(['lastUpdateCheck'], (result) => {\n                    if (browser.runtime.lastError) {\n                        reject(browser.runtime.lastError);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            });\n            const now = Date.now();\n            const oneDay = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n            \n            if (lastCheck.lastUpdateCheck && (now - lastCheck.lastUpdateCheck) < oneDay) {\n                LogDev(\"Update check skipped - checked recently\", \"system\");\n                return;\n            }\n        }\n        \n        // Update last check time\n        const now = Date.now();\n        await new Promise((resolve, reject) => {\n            browser.storage.local.set({ lastUpdateCheck: now }, () => {\n                if (browser.runtime.lastError) {\n                    reject(browser.runtime.lastError);\n                } else {\n                    resolve();\n                }\n            });\n        });\n        \n        // Check GitHub for latest release\n        const response = await fetch('https://api.github.com/repos/CrudePixels/Goonopticon/releases/latest');\n        if (!response.ok) {\n            LogDev(\"Failed to fetch release info: \" + response.status, \"error\");\n            return;\n        }\n        \n        const releaseData = await response.json();\n        const latestVersion = releaseData.tag_name.replace('v', ''); // Remove 'v' prefix if present\n        \n        LogDev(\"Latest version: \" + latestVersion, \"system\");\n        \n        // Compare versions\n        if (isNewerVersion(latestVersion, currentVersion)) {\n            LogDev(\"New version available: \" + latestVersion, \"system\");\n            \n            // Store update info for popup to display\n            await new Promise((resolve, reject) => {\n                browser.storage.local.set({\n                    updateAvailable: true,\n                    latestVersion: latestVersion,\n                    currentVersion: currentVersion,\n                    releaseUrl: releaseData.html_url,\n                    releaseNotes: releaseData.body\n                }, () => {\n                    if (browser.runtime.lastError) {\n                        reject(browser.runtime.lastError);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n            \n            // Show notification\n            browser.notifications.create({\n                type: 'basic',\n                iconUrl: 'Resources/icon-48.png',\n                title: 'Goonopticon Update Available',\n                message: `Version ${latestVersion} is now available! Click to update.`\n            });\n        } else {\n            LogDev(\"Extension is up to date\", \"system\");\n            await new Promise((resolve, reject) => {\n                browser.storage.local.set({ updateAvailable: false }, () => {\n                    if (browser.runtime.lastError) {\n                        reject(browser.runtime.lastError);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        \n    } catch (error) {\n        LogDev(\"Error checking for updates: \" + error.message, \"error\");\n    }\n}\n\n// Simple version comparison function\nfunction isNewerVersion(version1, version2) {\n    const v1parts = version1.split('.').map(Number);\n    const v2parts = version2.split('.').map(Number);\n    \n    for (let i = 0; i < Math.max(v1parts.length, v2parts.length); i++) {\n        const v1part = v1parts[i] || 0;\n        const v2part = v2parts[i] || 0;\n        \n        if (v1part > v2part) return true;\n        if (v1part < v2part) return false;\n    }\n    \n    return false;\n}\n\n// Check for updates on startup\ncheckForUpdates();"],"names":[],"sourceRoot":""}